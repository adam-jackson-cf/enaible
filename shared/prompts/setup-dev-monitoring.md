# setup-dev-monitoring v0.4

## Purpose

Configure development monitoring by generating Makefile and Procfile orchestration, central logging, and CLAUDE.md updates tailored to the project’s runnable components.

## Variables

- `$TARGET_PATH` ← repository root (default `.`)
- `$SCRIPT_PATH` ← resolved monitoring script directory (dependency installer only)
- `$SCRIPTS_ROOT` ← base path for PYTHONPATH (dependency installer only)
- `$COMPONENTS_JSON` ← JSON array of services: `[{ name, label, cwd, start_command, port|null }]`
- `$WATCH_GLOBS` ← optional CSV for non‑native watch patterns
- `$LOG_FILE` ← unified log path (default `./dev.log`)

## Instructions

- Discover real start commands; refuse placeholder or missing commands.
- Keep the Python dependency installer; do not use Python generators for file content.
- Write Makefile, Procfile, and documentation directly as specified below.
- Exclude overlapping orchestrators when granular per‑component commands are preferable.
- Confirm before excluding components, installing dependencies, or overwriting files.
- Always log to `$LOG_FILE` (default `./dev.log`), never `/dev.log`.
- Validate generated files (syntax, logging pipeline, ports) before success.

## Workflow

1. Verify prerequisites (dependency installer only)
   - Check for dependency installer: `ls .claude/scripts/setup/monitoring/*.py || ls "$HOME/.claude/scripts/setup/monitoring/install_monitoring_dependencies.py"`.
   - If not found, prompt for a directory that includes `install_monitoring_dependencies.py`; exit if unavailable.
   - Verify Python is present: `python3 --version || python --version` (abort if missing).
2. Environment preparation (dependency installer only)
   - Resolve `$SCRIPT_PATH` (project‑level → user‑level → prompt for path).
   - Compute `$SCRIPTS_ROOT` and run `PYTHONPATH="$SCRIPTS_ROOT" python -c "import core.base; print('env OK')"`; abort on failure.
   - Dry‑run dependency check: `python "$SCRIPT_PATH"/install_monitoring_dependencies.py --dry-run`.
   - If tools missing, **STOP:** “Install missing core tools: <list>? (y/n)”. On approval, run full install.
3. Project component discovery
   - Use `ls`, `glob`, and package manifests to identify runnable services (frontend, backend, workers, databases, build tools).
   - Determine true start commands from scripts, documentation, or framework defaults.
   - Assign log labels (FRONTEND, BACKEND, WORKER, etc.) and capture port information.
   - Verify each component has a runnable command; halt if any remain unresolved.
4. Component overlap analysis
   - Detect orchestrators that duplicate child services; mark for exclusion when appropriate.
   - Identify port conflicts.
   - **STOP:** “Exclude overlapping components: <list>? (y/n)” Adjust list based on user input.
5. Watch pattern analysis
   - Decide which technologies rely on native hot reload vs. external watchers.
   - Build `WATCH_PATTERNS[]` only for components lacking native watching.
   - **STOP:** “Component analysis complete. Proceed with setup? (y/n)”
6. Existing file handling
   - Detect existing `Makefile` or `Procfile`.
   - **STOP:** “Existing Procfile/Makefile found. Choose action: (b)ackup, (o)verwrite, (c)ancel.”
   - Respect choice and create timestamped backups when requested.
7. Write Makefile (direct content)

   - Write a Makefile that defines a timestamped log pipeline, core targets, and one run‑<LABEL> target per component.
   - Content to write (template; expand per component from `$COMPONENTS_JSON`):

     ```make
     # Generated by setup-dev-monitoring on $(shell date +%Y-%m-%dT%H:%M:%S)
     LOG_FILE ?= ./dev.log

     define PIPE_TS
     2>&1 | while IFS= read -r line; do \
       echo "[$$(date '+%H:%M:%S')] [$$1] $$line"; \
     done | tee -a $(LOG_FILE)
     endef

     .PHONY: dev status logs clean-logs $(COMPONENT_TARGETS)

     dev: ## Start all services (parallel)
     	@$(MAKE) -j $(COMPONENT_TARGETS)

     status: ## Show service processes
     	@ps aux | egrep "node|bun|python|next|vite|convex|fastapi|uvicorn" | egrep -v "grep" || true

     logs: ## Tail unified log
     	@touch $(LOG_FILE)
     	@tail -f $(LOG_FILE)

     clean-logs: ## Truncate logs
     	@: > $(LOG_FILE)

     # Per-component targets (expand once per component)
     # Example: FRONTEND at apps/web with Next.js on port 3000
     run-FRONTEND:
     	@cd apps/web && PORT=3000 next dev -- --port 3000 $(call PIPE_TS,FRONTEND)

     # Example: BACKEND at packages/api with bun
     run-BACKEND:
     	@cd packages/api && bun run dev $(call PIPE_TS,BACKEND)
     ```

   - Expansion rules:
     - `COMPONENT_TARGETS` = space‑joined list `run-<LABEL>` for all components.
     - For each component: `LABEL` is UPPER_SNAKE; `cwd` = component.cwd; `start_command` = component.start_command.
     - If Next.js dev and `port` present: prefix `PORT=<port>` and append `-- --port <port>`.

8. Write Procfile (direct content)
   - Add one line per component that cds into `cwd`, runs the start command, and applies a timestamped log pipeline to `$LOG_FILE`.
   - Content to write (expand per component):
     ```Procfile
     FRONTEND: cd apps/web && PORT=3000 next dev -- --port 3000 2>&1 | while IFS= read -r line; do echo "[$(date '+%H:%M:%S')] [FRONTEND] $$line"; done | tee -a ./dev.log
     BACKEND: cd packages/api && bun run dev 2>&1 | while IFS= read -r line; do echo "[$(date '+%H:%M:%S')] [BACKEND] $$line"; done | tee -a ./dev.log
     ```
   - Always use `./dev.log` for writeability; never `/dev.log`.
9. Update AGENTS.md or CLAUDE.md (direct content)

   - Prefer `AGENTS.md` if present; otherwise update/create `CLAUDE.md`.
   - Insert or upsert this Development section:

     ```md
     ## Development

     | Command         | Description            |
     | --------------- | ---------------------- |
     | make dev        | Start all services     |
     | make status     | Show running processes |
     | make logs       | Tail ./dev.log         |
     | make clean-logs | Truncate unified log   |

     Services log to `./dev.log` with timestamps. Each service can be run individually via `make run-<LABEL>`.
     ```

10. Validation

- Ensure every component has a corresponding `run-<LABEL>` target and a Procfile process line.
- Verify logging pipeline targets `$LOG_FILE` (`./dev.log`) in both files.
- For Next.js services with `port`, verify both `PORT=<port>` and `-- --port <port>` are present.
- Makefile syntax: `make -n dev` succeeds; if `foreman` is installed, `foreman check` succeeds.
- Summarize results and provide run commands: `make dev`, `make status`, `make logs`.

## Output

```md
# RESULT

- Summary: Development monitoring configured for <component count> components.

## COMPONENTS

- <Label> — <cwd> — <start_command> (port: <value>)

## FILES

- Makefile: <status (created/backed up + created)>
- Procfile: <status>
- CLAUDE.md: <updated sections>
- dev.log: <logging pipeline enabled>

## VALIDATION

- make dev: <pass|not run>
- make status: <pass|not run>
- make logs: <pass|not run>

## NEXT STEPS

1. Run `make dev` to start services.
2. Use `make logs` to tail `./dev.log`.
3. Review CLAUDE.md for updated workflow commands.
```

## Examples

```bash
# Configure monitoring for current repo
/setup-dev-monitoring
```
