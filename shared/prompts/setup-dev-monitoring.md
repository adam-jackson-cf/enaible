# setup-dev-monitoring v0.4

## Purpose

Configure development monitoring by generating Makefile and Procfile orchestration, central logging, and CLAUDE.md updates tailored to the project’s runnable components.

## Variables

### Required

- (none)

### Optional (derived from $ARGUMENTS)

- @TARGET_PATH = --target-path — repository root for discovery (default .)
- @AUTO = --auto — skip STOP confirmations (auto-approve checkpoints)

### Derived (internal)

- @COMPONENTS_JSON = <config> — JSON array describing services ({ name, label, cwd, start_command, port|null })
- @WATCH_GLOBS = <config> — CSV of custom globs for components lacking native hot reload
- @LOG_FILE = <config> — unified log destination for orchestrated services (default ./dev.log)

## Instructions

- Discover real start commands; refuse placeholder or missing commands.
- Keep the Python dependency installer; do not use Python generators for file content.
- Write Makefile, Procfile, and documentation directly as specified below.
- Exclude overlapping orchestrators when granular per‑component commands are preferable.
- Confirm before excluding components, installing dependencies, or overwriting files.
- Always log to @LOG_FILE (default `./dev.log`), never `/dev.log`.
- Validate generated files (syntax, logging pipeline, ports) before success.
- Respect STOP confirmations unless @AUTO is provided; when auto is active, treat checkpoints as approved without altering other behavior.

## Workflow

1. Dependency check (Enaible-managed)
   - !`uv sync --project tools/enaible`
   - Dry-run tooling verification:
     ```bash
     PYTHONPATH=shared \
       uv run --project tools/enaible python shared/setup/monitoring/install_monitoring_dependencies.py --dry-run
     ```
   - If prerequisites are missing, **STOP (skip when @AUTO):** “Install missing core tools: <list>? (y/n)”. On approval, rerun the command without `--dry-run`.
     - When @AUTO is present, continue immediately, record internally that the confirmation was auto-applied, and rerun the command without `--dry-run`.
2. Project component discovery
   - Use `ls`, `glob`, and package manifests to identify runnable services (frontend, backend, workers, databases, build tools).
   - Determine true start commands from scripts, documentation, or framework defaults.
   - Assign log labels (FRONTEND, BACKEND, WORKER, etc.) and capture port information.
   - Verify each component has a runnable command; halt if any remain unresolved.
3. Component overlap analysis
   - Detect orchestrators that duplicate child services; mark for exclusion when appropriate.
   - Identify port conflicts.
   - **STOP (skip when @AUTO):** “Exclude overlapping components: <list>? (y/n)” Adjust list based on user input.
     - When @AUTO is present, continue immediately and record internally that the confirmation was auto-applied.
4. Watch pattern analysis
   - Decide which technologies rely on native hot reload vs. external watchers.
   - Build `WATCH_PATTERNS[]` only for components lacking native watching.
   - **STOP (skip when @AUTO):** “Component analysis complete. Proceed with setup? (y/n)”
     - When @AUTO is present, continue immediately and record internally that the confirmation was auto-applied.
5. Existing file handling
   - Detect existing `Makefile` or `Procfile`.
   - **STOP (skip when @AUTO):** “Existing Procfile/Makefile found. Choose action: (b)ackup, (o)verwrite, (c)ancel.”
     - When @AUTO is present, follow the documented default (overwrite unless the prompt specifies otherwise) and record internally that the confirmation was auto-applied.
   - Respect choice and create timestamped backups when requested.
6. Write Makefile (direct content)

   - Write a Makefile that defines a timestamped log pipeline, core targets, and one run‑<LABEL> target per component.
   - Content to write (template; expand per component from `$COMPONENTS_JSON`):

     ```make
     # Generated by setup-dev-monitoring on $(shell date +%Y-%m-%dT%H:%M:%S)
     LOG_FILE ?= ./dev.log

     define PIPE_TS
     2>&1 | while IFS= read -r line; do \
       echo "[$$(date '+%H:%M:%S')] [$$1] $$line"; \
     done | tee -a $(LOG_FILE)
     endef

     .PHONY: dev status logs clean-logs $(COMPONENT_TARGETS)

     dev: ## Start all services (parallel)
     	@$(MAKE) -j $(COMPONENT_TARGETS)

     status: ## Show service processes
     	@ps aux | egrep "node|bun|python|next|vite|convex|fastapi|uvicorn" | egrep -v "grep" || true

     logs: ## Tail unified log
     	@touch $(LOG_FILE)
     	@tail -f $(LOG_FILE)

     clean-logs: ## Truncate logs
     	@: > $(LOG_FILE)

     # Per-component targets (expand once per component)
     # Example: FRONTEND at apps/web with Next.js on port 3000
     run-FRONTEND:
     	@cd apps/web && PORT=3000 next dev -- --port 3000 $(call PIPE_TS,FRONTEND)

     # Example: BACKEND at packages/api with bun
     run-BACKEND:
     	@cd packages/api && bun run dev $(call PIPE_TS,BACKEND)
     ```

   - Expansion rules:
     - `COMPONENT_TARGETS` = space‑joined list `run-<LABEL>` for all components.
     - For each component: `LABEL` is UPPER_SNAKE; `cwd` = component.cwd; `start_command` = component.start_command.
     - If Next.js dev and `port` present: prefix `PORT=<port>` and append `-- --port <port>`.

7. Write Procfile (direct content)
   - Add one line per component that cds into `cwd`, runs the start command, and applies a timestamped log pipeline to `$LOG_FILE`.
   - Content to write (expand per component):
     ```Procfile
     FRONTEND: cd apps/web && PORT=3000 next dev -- --port 3000 2>&1 | while IFS= read -r line; do echo "[$(date '+%H:%M:%S')] [FRONTEND] $$line"; done | tee -a ./dev.log
     BACKEND: cd packages/api && bun run dev 2>&1 | while IFS= read -r line; do echo "[$(date '+%H:%M:%S')] [BACKEND] $$line"; done | tee -a ./dev.log
     ```
   - Always use `./dev.log` for writeability; never `/dev.log`.
8. Update @SYSTEMS.md (direct content)

   - Insert or upsert this Development section:

     ```md
     ## Development

     | Command         | Description            |
     | --------------- | ---------------------- |
     | make dev        | Start all services     |
     | make status     | Show running processes |
     | make logs       | Tail ./dev.log         |
     | make clean-logs | Truncate unified log   |

     Services log to `./dev.log` with timestamps. Each service can be run individually via `make run-<LABEL>`.
     ```

9. Validation

- Ensure every component has a corresponding `run-<LABEL>` target and a Procfile process line.
- Verify logging pipeline targets `$LOG_FILE` (`./dev.log`) in both files.
- For Next.js services with `port`, verify both `PORT=<port>` and `-- --port <port>` are present.
- Makefile syntax: `make -n dev` succeeds; if `foreman` is installed, `foreman check` succeeds.
- Summarize results and provide run commands: `make dev`, `make status`, `make logs`.

## Output

```md
# RESULT

- Summary: Development monitoring configured for <component count> components.

## COMPONENTS

- <Label> — <cwd> — <start_command> (port: <value>)

## FILES

- Makefile: <status (created/backed up + created)>
- Procfile: <status>
- CLAUDE.md: <updated sections>
- dev.log: <logging pipeline enabled>

## VALIDATION

- make dev: <pass|not run>
- make status: <pass|not run>
- make logs: <pass|not run>

## NEXT STEPS

1. Run `make dev` to start services.
2. Use `make logs` to tail `./dev.log`.
3. Review CLAUDE.md for updated workflow commands.
```
